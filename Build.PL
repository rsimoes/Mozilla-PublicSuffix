#!/usr/bin/env perl

use strict;
use warnings FATAL => "all";
use utf8;
use open ":encoding(UTF-8)";
use Carp qw(croak);
use HTTP::Tiny;
use Module::Build;
use IO::File;
use Tie::File;
use URI;

my $builder = Module::Build->new(
    dist_name => "Mozilla-PublicSuffix",
    license => "MIT",
    dist_abstract => q(Get a domain name's public suffix via Mozilla's Public Suffix List),
    dist_author => q"Richard SimÃµes <rsimoes AT cpan DOT org>",
    dist_version_from => "lib/Mozilla/PublicSuffix.pm",
    # Prerequisites inserted by DistZilla:
    ##{ $plugin->get_prereqs ##}
);

my $dat_file = "effective_tld_names.dat";
my $system_dat_file = $builder->config('system_publicsuffix_list');
my $get_new_list = $builder->y_n(
    "Check for a new version of the Public Suffix List?", "N"
);
if ($get_new_list) {
    my $http = HTTP::Tiny->new( timeout => 6 );
    my $list_uri = URI->new(
        "http://mxr.mozilla.org/mozilla-central/source/netwerk/dns/$dat_file"
    );
    $list_uri->query_form({ raw => 1 });
    my %options = (
        headers => {
            "If-Modified-Since" => "Fri, 17 May 2013 00:00:00 UTC"
        }
    );
    my $response = $http->get($list_uri, \%options);
    if ( $response->{status} == 200 ) {
        IO::File->new($dat_file, "w")->print($response->{content});
    }
    elsif ( $response->{status} != 304 ) {
        croak "Unable to download public suffix list.";
    }
}

# Divide rules from list into sets:
my $rules = join " ", map {
    s/\s//g;
    if    ( s/^!// )        { $_ => "e" }  # exception rule
    elsif ( s/^\*\.// )     { $_ => "w" }  # wildcard rule
    elsif ( /^[\p{Word}]/ ) { $_ => "i" }  # identity rule
    else { () }
} IO::File->new($dat_file)->getlines;

tie my @pm, "Tie::File", "lib/Mozilla/PublicSuffix.pm";
for (@pm) {
	if ($system_dat_file) {
		s/(my %rules = qw\(\);)/$1\n_parse_file(\\%rules,\"$system_dat_file\");/ and last
	} else {
		s/(my %rules = qw\()\)/$1$rules)/ and last
	}
}
untie @pm;

$builder->create_build_script;
